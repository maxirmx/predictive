// Сфдд адщц
// Copyright  2022 Максим Самсонов, его родственники и знакомые
// License    https://github.com/maxirmx/predictive/blob/main/LICENSE MIT

'use strict';

import { invertedErlangB } from './util.js';


const precision = 4;  // точность вычислений, знаков после запятой, т.е. 10^(-precision)
const delta = 10**(-precision);

// Параметры:
//   agents - общее количество агентов
//   abandonRate - целевой процент отказов
//   hitRate - предполагаемый процент дозвона
//             Eсть разные методы оценки этого параметра, зависящие от страны, колл-центра, кампании ...
//              1. фактический процент дозвона за предыдущий интервал времени
//              2. ожидаемый процент дозвона для текущего времени, месяца, дня недели и т.д. на основе ранее собранной статистики
//              3. комбинация вариантов 1 и 2
//              
//   serviceTime - ожидаемое среднее время обслуживания (включая время на пост обработку)
//              Многие, если не все кампании являются "двухфакторными", в том смысле, что все успешные звоник делятся на две группы
//              1. "Короткиe", когда клиент быстро отказался от разговора
//              2. "Длинные", когда клиент согласился на разговор
//              причём соотношение коротких и длинных вызовов меняется в зависимости от времени суток, дня недели и т.т.
//              Если такая статистика есть, serviceTime считают как 
//              <ожидаемая доля коротких звонков>*<среднее время короткого звонка> + <ожидаемая доля длинных звонков>*<среднее время длинного звонка>
//              Например
//                  Среднее время короткого звонка - 1 минута
//                  Среднее время длинного звонка - 15 минута
//                  В 6 утра  коротких звонков 90%, в 18:00 - 10%
//                  Тогда, в 6 утра serviceTime - 2.4 минуты, а в 18:00 - 13.6 минут
//
//   actualAbandonRate - фактический процент отказов
//              Если используются статистические данные, собранные на больших интервалах времени, они могут "внезапно" стать неактуальными
//              Если такое случится, алгоритм слегка автоскорректируется
//              Если, не задумываясь, передавать actualAbandonRate = abandonRate, то коррекции не будет
//              
// Результат:
//   call flow (количество вызовов в единицу времени, ту же, что и serviceTime)
//   например, если на входе serviceTime был в секундах, то call flow будет в вызовах в секунду
//             если на входе serviceTime был в часах, то call flow будет в вызовах в час
//   это потому, что формула Эрланга - "безразмерная", в штуках
//   размерность приходит "снаружи"
//
//   0 (или неразумно маленькая величина) для call flow означает, что predictive в заданных параметрах не работает

function callFlow(agents, abandonRate, hitRate, serviceTime, actualAbandonRate) {
    var adjustedAbandonRate = 2.0 * abandonRate - actualAbandonRate;
    if (adjustedAbandonRate < delta) return 0.0;
    return invertedErlangB(agents, adjustedAbandonRate, precision)/serviceTime/hitRate;
}

export { callFlow };
